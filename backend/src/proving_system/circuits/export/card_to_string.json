{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"10519077483716314195","abi":{"parameters":[{"name":"card","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"}]},"visibility":"private"},"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7VWTW+DMAxNQ8LHqm7Sdt190k5hLaNHDtv+Bxrjd/SnDzRbfXVd0ASxFCXG9vPLI0FszJ/ZYWxo7WhmH42fNTSHZVauiBWswtOaic1YiGnF7zQXSn6yogiF6Lsm/jEc6sJc2sr894XQMIY+jBkBP2SE83G6Pg/Yd0c+niWuyYdxb87rB6gZ7ROwNyL2pfSNuefhTFSM7yLgD/b2pPDnXlvSKJCfKFzkXUgm8BBD1uE68jnquL8HTnO8xpGSbyHfT+TLdybxU6GJv6FZoTxr1tEiSC5+gosXuS80j/5zfK7lf7hac/0OUuDEmmcz8VTBjrzPH+6Xi71kN7ho+0beXuRKP1dw+BtqlboR+zW+Dp3GwSkc5H2bu89aDPnvjH6fMYa1dkIzxtia8/+JO13GG7Ncr/oYAnNKCN9DfzQHccyvyL8D/jy7BTz7ui37fdu3Vdt1h+/2UeAb0GzU6RdYm79B7QoAAA==","debug_symbols":"nZNNjoQgEEbvUmsW8mcrV+l0DCp2SAgaWieZGO8+hYy0vZjFuOGJVd+zNLJCb9rl2Vg/jC9Q9xXaYJ2zz8aNnZ7t6PHuCkVcaAmKEqC3hCqhBsUIsCKBJrAEDoojBCiBkAmYk4h6By8S6N7JWULKcZEgE8odAltKBLbcto3AMWYzB2PilKe58W0mHYyfQfnFOQJf2i1702vSfuesA1YLAsb3SBQO1pl4tZF3uvg7yjg90owzmgXyHwbBs0GW1wwsG8prhkpkQ82vGATNM4hr30GUb8NNXjPQbKg+DQ/c6c6Gj/96i65gdevM73ZYfHeqzt/TUTnOxRTGzvRLMNF0Ohy43kVFJH9s8Wk/","file_map":{"50":{"source":"use dep::std;\n\npub global STANDARD_DECK_SIZE: u32 = 52;\npub global CARDS_PER_PLAYER: u32 = 5;\npub global GAMMA: Field = 12345;\n\n#[export]\npub fn shuffle_deck(seed: Field) -> [Field; STANDARD_DECK_SIZE] {\n    // DECK AUTHENTICITY: Initialize deck with sequential values representing playing cards\n    let mut deck: [Field; STANDARD_DECK_SIZE] = [0; STANDARD_DECK_SIZE];\n    for i in 0..STANDARD_DECK_SIZE {\n        deck[i] = i as Field;\n    }\n\n    // SHUFFLE ACTION: Perform Fisher-Yates shuffle\n    for n in 0..deck.len() {\n        let i = deck.len() - 1 - n;\n        let rng = std::hash::pedersen_hash([seed, i as Field]);\n        let j = rng as u32 % (i + 1);\n        let mut selected_value: Field = 0;\n        for k in 0..(i + 1) {\n            selected_value += deck[k] * ((k == j) as Field);\n        }\n        for k in 0..(i + 1) {\n            deck[k] = deck[k] * (((k != i) & (k != j)) as Field)\n                + deck[i] * ((k == j) as Field)\n                + selected_value * (((k == i) & (k != j)) as Field);\n        }\n    }\n    deck\n}\n\npub fn constrain_deck_integrity<let N: u32>(original_deck: [Field; N], shuffled_deck: [Field; N]) {\n    assert(original_deck.len() == shuffled_deck.len(), \"[ERR: Deck]: Deck length mismatch!\");\n    let gamma = std::hash::pedersen_hash([GAMMA]);\n    let mut expected_product: Field = 1;\n    let mut actual_product: Field = 1;\n    for i in 0..original_deck.len() {\n        expected_product *= (gamma + original_deck[i]);\n        actual_product *= (gamma + shuffled_deck[i]);\n    }\n    assert(expected_product == actual_product, \"[ERR: Deck]: Deck integrity compromised!\");\n}\n\n#[export]\npub fn deal_cards(\n    shuffled_deck: [Field; STANDARD_DECK_SIZE],\n    seed: Field,\n) -> ([Field; CARDS_PER_PLAYER], Field) {\n    let mut cards: [Field; CARDS_PER_PLAYER] = [0; CARDS_PER_PLAYER];\n    let mut commitment: Field = std::hash::pedersen_hash([seed]);\n    for i in 0..CARDS_PER_PLAYER {\n        cards[i] = shuffled_deck[i];\n        commitment = std::hash::pedersen_hash([commitment, shuffled_deck[i]]);\n    }\n    (cards, commitment)\n}\n\n#[export]\nunconstrained fn card_to_string(card: Field) -> (Field, Field) {\n    // Returns (rank, suit) where:\n    // rank: 2 - 10 , 11 = J, 12= Q, 13 = K, 14 = A\n    // suit: 0=Hearts, 1=Diamonds, 2=Clubs, 3=Spades\n    let card_u32 = card as u32;\n    let mut rank = (card_u32 % 13) as Field;\n    rank = if ( rank == 0) { 13 } else if ( rank == 1) { 14 } else { rank } ;\n    let suit = (card_u32 / 13) as Field;\n    (rank, suit)\n}\n","path":"/home/ally/DevEnv/pvtDock/KH/card-war/backend/src/proving_system/circuits/assist/src/lib.nr"}},"names":["card_to_string"],"brillig_names":["card_to_string"]}